{
  "master": {
    "tasks": [],
    "metadata": {
      "created": "2025-06-24T05:57:29.805Z",
      "updated": "2025-06-24T05:57:29.805Z",
      "description": "Tasks for master context"
    }
  },
  "features": {
    "tasks": [
      {
        "id": 1,
        "title": "Add video support for URL API endpoint",
        "description": "Extend the existing URL API endpoint to accept and process video files, enabling recipe extraction from video content such as cooking tutorials and recipe demonstrations.",
        "details": "Implementation involves:\n\n1. **Backend API Enhancement**:\n   - Modify the URL endpoint to detect video content types (mp4, avi, mov, webm, etc.)\n   - Integrate video processing library (e.g., opencv-python, moviepy) for frame extraction\n   - Implement video-to-text extraction using OCR on key frames or video transcription\n   - Add video metadata extraction (duration, resolution, format)\n   - Update request validation to accept video URLs and file uploads\n\n2. **Video Processing Pipeline**:\n   - Extract key frames at regular intervals or scene changes\n   - Apply OCR to frames containing text (recipe ingredients, instructions)\n   - Implement audio transcription if video contains spoken instructions\n   - Combine extracted text from multiple sources (OCR + transcription)\n   - Clean and structure the extracted content into recipe format\n\n3. **API Response Enhancement**:\n   - Include video metadata in response (duration, source URL, processing method)\n   - Add confidence scores for extracted content\n   - Provide frame timestamps for extracted text segments\n   - Handle cases where no recipe content is detected\n\n4. **Error Handling**:\n   - Validate video accessibility and format support\n   - Handle network timeouts for large video files\n   - Implement fallback mechanisms for processing failures\n   - Add appropriate error messages for unsupported formats",
        "testStrategy": "1. **Unit Tests**:\n   - Test video format detection and validation\n   - Verify frame extraction functionality with sample videos\n   - Test OCR accuracy on recipe text in video frames\n   - Validate error handling for invalid/corrupted videos\n\n2. **Integration Tests**:\n   - Test end-to-end video processing with various video formats (mp4, webm, mov)\n   - Verify API response structure includes video metadata\n   - Test processing of cooking tutorial videos from popular platforms\n   - Validate timeout handling for large video files\n\n3. **Performance Tests**:\n   - Measure processing time for videos of different lengths\n   - Test memory usage during video processing\n   - Verify cleanup of temporary files after processing\n\n4. **Manual Testing**:\n   - Process real cooking videos with visible recipe text\n   - Test videos with both spoken and written recipe content\n   - Verify extracted recipes are accurate and well-formatted\n   - Test edge cases: videos without recipe content, very short/long videos",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create upload video API endpoint",
        "description": "Implement a dedicated API endpoint for direct video file uploads, enabling users to upload video files containing recipes for processing and extraction.",
        "details": "Implementation involves:\n\n1. **API Endpoint Creation**:\n   - Create POST /api/upload/video endpoint in the appropriate router\n   - Implement multipart/form-data handling for video file uploads\n   - Add file size validation and limits (e.g., max 500MB)\n   - Validate uploaded file types (mp4, avi, mov, webm, mkv)\n   - Generate unique identifiers for uploaded videos\n\n2. **File Storage Management**:\n   - Implement temporary file storage with cleanup mechanisms\n   - Add file path sanitization and security validation\n   - Create storage directories with proper permissions\n   - Implement file cleanup after processing completion\n\n3. **Request/Response Models**:\n   - Create VideoUploadRequest model with file validation\n   - Design VideoUploadResponse with upload status and processing info\n   - Add progress tracking for large file uploads\n   - Include error responses for invalid files or upload failures\n\n4. **Integration with Video Processing**:\n   - Connect to existing video processing pipeline from Task 1\n   - Pass uploaded file path to video processing functions\n   - Handle processing status updates and results\n   - Implement async processing for large video files\n\n5. **Security and Validation**:\n   - Add MIME type verification beyond file extension checking\n   - Implement virus scanning if required\n   - Add rate limiting for upload endpoints\n   - Validate file headers to prevent malicious uploads",
        "testStrategy": "1. **Unit Tests**:\n   - Test file upload validation with various file types and sizes\n   - Verify MIME type detection and security checks\n   - Test file storage and cleanup mechanisms\n   - Validate request/response model serialization\n\n2. **Integration Tests**:\n   - Test complete upload-to-processing workflow\n   - Verify integration with video processing pipeline\n   - Test error handling for corrupted or invalid files\n   - Validate async processing status updates\n\n3. **Load Testing**:\n   - Test concurrent file uploads\n   - Verify performance with large video files\n   - Test system behavior under storage constraints\n\n4. **Security Testing**:\n   - Test with malicious file uploads\n   - Verify file type spoofing protection\n   - Test rate limiting effectiveness\n   - Validate proper file cleanup and no data leaks",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Add comprehensive image support with scraping, editing, and PDF display",
        "description": "Implement complete image functionality including URL image scraping, image upload/edit capabilities in demo mode, and image display in PDF exports.",
        "details": "Implementation involves:\n\n1. **Backend Image Scraping Enhancement**:\n   - Extend URL processing to detect and extract recipe images from web pages\n   - Implement image scraping using BeautifulSoup to find recipe-related images\n   - Add image download and validation (format, size, content type)\n   - Implement image optimization and resizing for storage efficiency\n   - Add image metadata extraction (dimensions, format, file size)\n   - Update Recipe model to include image_url and image_metadata fields\n\n2. **Image Upload API**:\n   - Create POST /api/recipe/image endpoint for direct image uploads\n   - Implement multipart/form-data handling for image files\n   - Add image validation (JPEG, PNG, WebP formats, max 10MB)\n   - Implement image storage with unique naming and path management\n   - Add image processing pipeline (resize, optimize, generate thumbnails)\n\n3. **Demo Frontend Image Integration**:\n   - Add image upload component to edit mode interface\n   - Implement image preview and crop functionality\n   - Add image removal and replacement options\n   - Update recipe display components to show images\n   - Integrate with existing edit recipe screen functionality\n   - Add drag-and-drop image upload support\n\n4. **PDF Export Image Support**:\n   - Modify HTML template system to include image placeholders\n   - Update weasyprint PDF generation to embed images\n   - Implement responsive image sizing for PDF layout\n   - Add image quality optimization for PDF output\n   - Handle RTL layout considerations for image positioning\n   - Support for multiple images per recipe in PDF format\n\n5. **Database Schema Updates**:\n   - Add image-related fields to Recipe model\n   - Implement image storage path management\n   - Add image metadata tracking (upload date, file size, dimensions)\n   - Create database migrations for new image fields",
        "testStrategy": "1. **Backend Image Processing Tests**:\n   - Test image scraping from various recipe websites\n   - Verify image download and validation functionality\n   - Test image optimization and resizing algorithms\n   - Validate image upload API with different file formats and sizes\n   - Test error handling for corrupted or invalid images\n\n2. **Frontend Integration Tests**:\n   - Test image upload component in edit mode\n   - Verify image preview and crop functionality\n   - Test drag-and-drop upload behavior\n   - Validate image display in recipe view components\n   - Test image removal and replacement workflows\n\n3. **PDF Export Tests**:\n   - Verify images appear correctly in PDF exports\n   - Test image quality and sizing in PDF output\n   - Validate RTL layout with images\n   - Test PDF generation with multiple images per recipe\n   - Verify image embedding doesn't break PDF structure\n\n4. **Performance Tests**:\n   - Test large image upload handling\n   - Verify image processing doesn't block API responses\n   - Test PDF generation time with image-heavy recipes\n   - Validate storage space management for images",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-24T07:14:50.441Z",
      "updated": "2025-06-24T21:21:53.906Z",
      "description": "Tag created on 6/24/2025"
    }
  },
  "demo-future-enhancement": {
    "tasks": [
      {
        "id": 1,
        "title": "Enhanced OAuth Error Handling with Network Detection",
        "description": "Implement comprehensive OAuth error handling including network connectivity detection, timeout protection, and graceful offline scenario management to prevent browser redirect failures.",
        "details": "Implement network connectivity detection using navigator.onLine and periodic connectivity checks before initiating OAuth flows. Add timeout protection (30-45 seconds) for OAuth redirects using Promise.race with AbortController for cleanup. Create error categorization system distinguishing between network errors, OAuth provider errors, and timeout scenarios. Implement graceful offline handling that shows user-friendly messages instead of allowing browser 'no internet' pages. Add retry mechanisms with exponential backoff for transient network issues. Create recovery flows that allow users to retry authentication once connectivity is restored. Include proper error logging and user feedback for different failure scenarios. Ensure OAuth state parameters are properly cleaned up on failures to prevent stale authentication attempts.",
        "testStrategy": "Test network detection accuracy by simulating offline/online states using browser dev tools. Verify timeout protection by mocking slow OAuth provider responses and confirming proper cleanup. Test offline scenarios by disconnecting network during OAuth flow and verifying user-friendly error messages appear instead of browser error pages. Validate error categorization by triggering different failure types (network, provider, timeout) and confirming appropriate user messaging. Test recovery flows by going offline during auth, then reconnecting and retrying. Verify OAuth state cleanup by checking localStorage/sessionStorage after failed attempts. Conduct cross-browser testing for network detection reliability.",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Show remaining quota in processing components",
        "description": "Add visual quota indicators to recipe processing components (TextProcessor, UrlProcessor, ImageProcessor) that display remaining requests count and usage percentage for authenticated users.",
        "details": "Create a reusable QuotaIndicator component that displays remaining requests count and visual percentage bar using current quota state from authentication context. Integrate the indicator into TextProcessor, UrlProcessor, and ImageProcessor components, positioning it prominently near processing buttons. The indicator should show 'X of 5 requests remaining' text with a progress bar visualization using Tailwind CSS. Implement real-time updates by subscribing to quota changes in the authentication context. Add conditional rendering to only show quota for authenticated users, hiding it for unauthenticated or admin users. Style the indicator with appropriate colors (green for plenty remaining, yellow for low, red for exhausted). Include smooth animations for quota updates using Framer Motion. Handle edge cases like loading states during quota fetch and error states if quota data is unavailable. Ensure the component is accessible with proper ARIA labels and keyboard navigation support.",
        "testStrategy": "Test quota display accuracy by comparing shown values with actual database records for test users. Verify real-time updates by processing recipes and confirming quota decrements immediately. Test visual states by artificially setting different quota levels (full, half, low, exhausted) and verifying appropriate styling. Confirm component only appears for authenticated non-admin users by testing with different user types. Test responsive design across mobile and desktop viewports. Verify accessibility with screen readers and keyboard navigation. Test error handling by simulating quota fetch failures and confirming graceful degradation.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Show quota exceeded component when opening cards at quota limit",
        "description": "Automatically display quota exceeded modal/component when users who have reached their limit try to open or interact with processing cards, preventing wasted time and improving user experience.",
        "details": "Create a QuotaExceededModal component that displays when users at quota limit attempt to interact with processing cards. The modal should show clear messaging about quota exhaustion, remaining time until reset (if applicable), and options to contact for additional quota or upgrade. Implement quota check logic in card interaction handlers (onClick, onFocus) that prevents opening/expanding cards when quota is exhausted. Add visual cues to processing cards when quota is exceeded - dim the cards, show overlay text, or disable interactive elements. Integrate with existing quota state management from authentication context to check current usage before allowing card interactions. The component should be responsive, accessible (ARIA labels, keyboard navigation), and styled consistently with the existing design system. Include animation transitions for smooth modal appearance and card state changes. Ensure the modal can be dismissed and users can still navigate to other parts of the application.",
        "testStrategy": "Test quota exceeded detection by setting user quota to 0 and attempting to interact with processing cards, verifying modal appears immediately. Test modal dismissal functionality and ensure users can still navigate the application. Verify visual cues on cards are applied correctly when quota is exceeded - cards should appear disabled/dimmed. Test with different quota states (1 remaining, 0 remaining) to ensure proper threshold detection. Test accessibility by navigating with keyboard and screen reader, ensuring proper ARIA attributes and focus management. Verify modal styling matches design system and displays correctly on mobile devices. Test edge cases like quota changing while modal is open and ensure proper state synchronization.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "When recipe extraction fails, show a message to the user",
        "description": "Implement basic error handling for recipe extraction failures to show clear error messages to users when the API request fails or when recipe extraction is unsuccessful.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "details": "Implement error handling for two main failure scenarios:\n\n**Error Scenarios:**\n1. **API Request Failures** - Network errors, server errors, timeouts, or service unavailability\n2. **Recipe Extraction Failures** - API request succeeds but extraction fails, resulting in fallback content\n\n**Implementation Requirements:**\n- Display clear, user-friendly error messages for each scenario\n- Handle API request failures (network issues, server errors, timeouts)\n- Handle extraction failures when API returns fallback results\n- Provide actionable next steps to users\n- Maintain good user experience during error states\n\n**Error Message Strategy:**\n- API failures: \"Unable to connect to the recipe service. Please check your connection and try again.\"\n- Extraction failures: \"We couldn't extract the recipe properly. Please try a different URL or paste the recipe text directly.\"",
        "testStrategy": "Test error handling for API request failures (simulate network errors, server errors, timeouts). Test extraction failure handling when API returns fallback results. Verify appropriate error messages display for each scenario. Test that error states don't break the main application flow. Validate users can take suggested actions after errors occur. Test error message display on mobile and desktop.",
        "subtasks": [
          {
            "id": 1,
            "title": "Handle API request failures",
            "description": "Implement error handling for when the API request itself fails due to network or server issues",
            "status": "pending",
            "dependencies": [],
            "details": "Catch and handle API request failures including network errors, server errors, and timeouts. Display appropriate error message to user with suggestion to retry.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Handle recipe extraction failures",
            "description": "Implement error handling for when API request succeeds but recipe extraction fails",
            "status": "pending",
            "dependencies": [],
            "details": "Detect when API returns fallback results due to extraction failures. Show error message indicating extraction didn't work properly and suggest alternative approaches.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add error message localization",
            "description": "Add localized error messages for both failure scenarios",
            "status": "pending",
            "dependencies": [],
            "details": "Create locale entries for API request failures and extraction failures. Ensure messages are user-friendly and provide actionable next steps.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Image Processing opens after sign in for no reason",
        "description": "When the user signs in, the processing image component sometimes expands even if the user didn't click on it",
        "details": "This happens because this was last card used, and the open state is persisted",
        "testStrategy": "Test authenticated access - verify unauthenticated users cannot access /my-recipes route. Test recipe storage after successful API processing calls. Verify RLS policies prevent cross-user access to recipes. Test search functionality with various keyword combinations. Validate filtering by date ranges, tags, and source types. Test sorting options maintain correct order. Verify recipe deletion removes from database and updates UI. Test recipe editing updates database and reflects changes immediately. Test empty state displays when user has no recipes. Validate pagination or infinite scroll loads additional recipes correctly. Test responsive design on mobile and desktop. Verify error handling for database operations.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "My recipes button in navigation not visible in mobile",
        "description": "The my recipes button is not visible in mobile",
        "details": "The my recipes button is not visible in mobile",
        "testStrategy": "Test authenticated access - verify unauthenticated users cannot access /my-recipes route. Test recipe storage after successful API processing calls. Verify RLS policies prevent cross-user access to recipes. Test search functionality with various keyword combinations. Validate filtering by date ranges, tags, and source types. Test sorting options maintain correct order. Verify recipe deletion removes from database and updates UI. Test recipe editing updates database and reflects changes immediately. Test empty state displays when user has no recipes. Validate pagination or infinite scroll loads additional recipes correctly. Test responsive design on mobile and desktop. Verify error handling for database operations.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "PWA support",
        "description": "Add PWA support to the application",
        "details": "Add PWA support to the application - include app logo and name, and add a manifest.json file",
        "testStrategy": "Test PWA support by installing the app on a mobile device and verifying it works correctly. Verify the app icon and name are displayed correctly. Verify the manifest.json file is correctly configured. Verify the app works correctly in offline mode. Verify the app works correctly in the home screen.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Add share option to PDF - implement functionality to share generated PDF recipes via various methods",
        "description": "Implement comprehensive PDF sharing functionality that allows users to share their generated recipe PDFs through multiple channels including email, social media, direct download, and cloud storage services.",
        "details": "Implementation should include: 1) Create a share modal/dropdown component that appears after PDF generation with multiple sharing options, 2) Implement email sharing functionality with customizable subject line and message body, integrating with email service provider (SendGrid, AWS SES, or similar), 3) Add social media sharing capabilities for platforms like Facebook, Twitter, Pinterest with proper Open Graph meta tags and recipe preview images, 4) Implement direct download option with proper file naming convention (recipe-title-date.pdf), 5) Add cloud storage integration for services like Google Drive, Dropbox, or OneDrive using their respective APIs, 6) Create copy-to-clipboard functionality for shareable links if recipes are made publicly accessible, 7) Implement sharing analytics to track which sharing methods are most popular, 8) Add share history feature in user profiles to track previously shared recipes, 9) Ensure proper error handling for failed sharing attempts with user-friendly error messages, 10) Implement rate limiting for sharing actions to prevent abuse, 11) Add privacy controls allowing users to choose sharing permissions (public, private, friends only), 12) Create responsive sharing interface that works on both desktop and mobile devices.",
        "testStrategy": "Create comprehensive test coverage including: 1) Unit tests for all sharing components and utility functions, 2) Integration tests for email sharing with mock email service provider, 3) Test social media sharing functionality with proper meta tag generation and URL formatting, 4) Verify PDF download functionality across different browsers and devices, 5) Test cloud storage integrations with mock API responses and error scenarios, 6) Validate sharing analytics tracking and data collection, 7) Test rate limiting functionality to ensure proper throttling of sharing requests, 8) Verify privacy controls and permission settings work correctly, 9) Test responsive design of sharing interface on various screen sizes, 10) End-to-end tests for complete sharing workflows from PDF generation to successful sharing, 11) Test error handling scenarios including network failures and API rate limits, 12) Verify sharing history functionality and proper data persistence.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-28T20:10:19.758Z",
      "updated": "2025-06-29T17:36:44.371Z",
      "description": "Future enhancements and nice-to-have features for the demo"
    }
  }
}